#!/bin/bash
# Build the project in release mode.
# The generated release directory and zip file name is in the format of:
#   "${RELEASE_FILE_PREFIX}${<target-name>}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}"
#
# All command-line arguments are passed to the executed `cargo` command.
#
# Optional environment variables:
#   $RELEASE_TARGETS
#     A space-separated list of build target identifiers;
#     valid identifiers are:
#       "default" (host's target triple)
#       "linux"   (host's target triple, this is stupid)
#       "osx"     (host's target triple, this is stupid)
#       "windows"
#     DEFAULT: "linux windows"
#   $RELEASE_DIR
#     Directory path for the generated releases to be saved to.
#     DEFAULT: "releases/" directory next to the project root.
#   $RELEASE_VERSION
#     Version number which is used in the generated release directory and zip file names.
#     Special values are:
#       "auto":  Dynamically figures out the highest version number in the releases directory
#                and uses its increment as the version. 0 if no version numbers were found.
#       "cargo": Get the version number from the `Cargo.toml` file.
#     DEFAULT: "cargo"
#   $RELEASE_FILE_PREFIX
#     Prefix string for the generated release directory and zip file.
#     DEFAULT: "ld44-postjam-"
#   $RELEASE_FILE_SUFFIX
#     Suffix string for the generated release directory and zip file.
#     DEFAULT: ""
#   $RELEASE_EXE_NAME
#     Name of the executable generated by cargo/rust.
#     DEFAULT: "ld44-stabman" or "ld44-stabman.exe" (for windows)
#   $RELEASE_EXE_NAME_OUTPUT
#     Name of the executable to be included in the release.
#     DEFAULT: "Stabman" or "Stabman.exe" (for windows)
#   $RELEASE_RESOURCES_DIR
#     Path to the resources directory.
#     DEFAULT: "${ROOT}/resources"
#   $RELEASE_RUST_VERSION
#     Which rust version to use.
#     Can be anything that can be passed to `rustup run VERSION`,
#     for example: "stable", "nightly", "1.34.2", "2019-01-01"
#     DEFAULT: "1.34.2"
#   $RELEASE_FEATURES
#     Comma-separated list of features to build with.
#     DEFAULT: ""
#   $RELEASE_WITH_CONTROLLER
#     If an additional executable with enabled controller support
#     shall be built in addition to the regular one.
#     Enabled if value is non-empty and not "0".
#     The extra executable will not be bundled with the generated zip archive,
#     instead it is placed in the releases directory in a zip archive with a name in the form of:
#       "${RELEASE_FILE_PREFIX}${<target-name>}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}${CONTROLLER_SUPPORT_SUFFIX}.zip"
#     The executable in this zip archive will have a name in the form of:
#       "${RELEASE_EXE_NAME}${CONTROLLER_SUPPORT_SUFFIX}(.exe)"
#     The ".exe" at the end is only appended for windows executables.
#     DEFAULT: "0"
#   $RELEASE_PRINT_CARGO_STDERR
#     If this variable is set, then all cargo commands are also printed to stderr,
#     not only to the `$LOGFILE`.
#     DEFAULT: ""

# shellcheck source=./share.sh
_dir="$( dirname "$0" )"
if [ -z "$TRAVIS" ]; then
  source "${_dir}/share.sh"
else
  source "${_dir}/travis-share.sh"
fi
unset _dir

set -e

WINDOWS_TARGET="x86_64-pc-windows-gnu"
CONTROLLER_SUPPORT_SUFFIX="-with-controller"
CARGO_MANIFEST="${ROOT}/Cargo.toml"
INCLUDE_FILES=()

function include_file {
  local filepath="${ROOT}/${1}"
  if [ -f "$filepath" ]; then
    INCLUDE_FILES+=("$filepath")
  else
    msg_strong "File to include in archive does not exist: $( colored "$COLOR_CODE" "$filepath" )"
  fi
}

function exclude_file {
  local filepath_remove=("${ROOT}/${1}")
  INCLUDE_FILES=("${INCLUDE_FILES[@]/$filepath_remove}")
}

include_file "README.md"
include_file "LICENSE"
include_file "resolution.txt"

function get_latest_version {
  check "sed"
  shopt -s nullglob
  [ -d "$RELEASE_DIR" ] || err "Directory '$RELEASE_DIR' doesn't exist."
  local highest=0
  local vers
  local vers_num
  local highest_num
  local file
  local new_vers

  for file in "$RELEASE_DIR"/*.zip; do
    vers="$( echo "$file" | grep -Eo '([0-9]\.?)+\.zip' | sed 's/\.zip//' )"
    if [ -n "$vers" ]; then
      vers_num="${vers//./}"
      highest_num="${highest//./}"
      [ $vers_num -gt $highest_num ] && highest="$vers"
    fi
  done

  new_vers="$( echo "$highest" | sed -E 's/(.*)([0-9]+)$/echo "\1$((\2+1))"/e' )"
  echo "$new_vers"
}

function get_version_from_cargo {
  check "grep"
  check "cut"
  check "tr"

  check_file "$CARGO_MANIFEST"

  local version
  if ! version="$(
    grep -Eom1 '^\s*version\s*=\s*.+$' "$CARGO_MANIFEST" \
      | cut -d'=' -f2 \
      | tr -d ' "'
  )"; then
    echo "ERROR"
    err "Error getting current crate version from file '${CARGO_MANIFEST}'"
  fi

  echo "$version"
}

function get_filename_for_target {
  local target="$1"
  [ -z "$target" ] && err "No target name given to function \`$0\`."
  echo "${RELEASE_FILE_PREFIX}${target}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}"
}

function mk_archive {
  local path="$1"
  local dir
  local filename
  local zipname
  [ -z "$1" ] && err "No path given to function \`$0\`."
  check "zip" && check "dirname" && check "basename"
  dir="$( dirname "$path" )"
  pushd "$dir"
  filename="$( basename "$path" )"
  zipname="${filename}.zip"
  prev_spacing="$spacing"
  spacing="$spacing  "
  msg "${prev_spacing}Zipping directory..."
  if [ -f "$zipname" ]; then
    msg "${spacing}zip archive already exists: $( colored "$COLOR_CODE" "$zipname" )"
    msg "${spacing}Deleting existing zip archive and creating new zip"
  fi
  try_run "zip -r $zipname $filename"
  try_run "rm -rf $filename"
  spacing="$prev_spacing"
  popd
}

function run {
  check "cargo"
  local target_display
  local filename
  local target
  local spacing

  case "$RELEASE_VERSION" in
    "auto")
      RELEASE_VERSION="$( get_latest_version )"
      ;;
    "cargo")
      RELEASE_VERSION="$( get_version_from_cargo )"
      ;;
  esac

  msg_strong "Building release version $( colored "$COLOR_CODE" "$RELEASE_VERSION" )"

  for target in "${RELEASE_TARGETS[@]}"; do
    spacing_strong="  "
    target_display="$( colored "$COLOR_CODE" "$target" )"
    msg_strong "${spacing_strong}Building release for $target_display"
    filename="$( get_filename_for_target "$target" )"
    spacing="${spacing_strong}${spacing_strong}"

    case "$target" in
      "linux" | "osx" | "default")
        local RUST_TARGET_DIR="${ROOT}/target/release"
        RELEASE_EXE_NAME="${RELEASE_EXE_NAME/.exe/}"
        RELEASE_EXE_NAME_OUTPUT="${RELEASE_EXE_NAME_OUTPUT/.exe/}"
        exclude_file "SDL2.dll"
        include_file "${RELEASE_EXE_NAME_OUTPUT}.desktop"

        build_release "$@"
        ;;

      "windows")
        if [ -n "$TRAVIS" ]; then
          # Use default rust target path when run from travis (is windows OS on travis)
          local RUST_TARGET_DIR="${ROOT}/target/release"
        else
          # Use non-default rust target path when cross-compiling
          local RUST_TARGET_DIR="${ROOT}/target/${WINDOWS_TARGET}/release"
        fi
        RELEASE_EXE_NAME="${RELEASE_EXE_NAME/.exe/}.exe"
        RELEASE_EXE_NAME_OUTPUT="${RELEASE_EXE_NAME_OUTPUT/.exe/}.exe"
        exclude_file "${RELEASE_EXE_NAME_OUTPUT}.desktop"
        [[ "$RELEASE_FEATURES" =~ "controller" ]] && include_file "SDL2.dll"

        build_release "$@" --target "$WINDOWS_TARGET"
        ;;

      *)
        err "Target '$target_display' is not valid"
        ;;
    esac

    msg_strong "${spacing_strong}Created release for ${target_display}\n${spacing_strong}$( colored "$COLOR_CODE" "${RELEASE_DIR}/${filename}.zip" )"
  done
}

# Pre-set local variables:
#   local target_display
#   local filename
#   local target
#   local spacing
function build_release {
  local features_arg=""
  [ -n "$RELEASE_FEATURES" ] && features_arg="--features ${RELEASE_FEATURES}"
  local prev_spacing="$spacing"
  spacing="$spacing  "
  msg "${prev_spacing}Compiling..."
  also_to_stderr="$RELEASE_PRINT_CARGO_STDERR" try_run \
    "cargo +${RELEASE_RUST_VERSION} build --release ${features_arg} $*"

  local target_dir="${RELEASE_DIR}/${filename}"
  mkdir "$target_dir"

  msg "${prev_spacing}Copying executable and resources..."
  try_run "cp ${RUST_TARGET_DIR}/${RELEASE_EXE_NAME} ${target_dir}/${RELEASE_EXE_NAME_OUTPUT}"
  try_run "cp -r $RELEASE_RESOURCES_DIR $target_dir"
  try_run "cp ${INCLUDE_FILES[*]} $target_dir";
  spacing="$prev_spacing"

  mk_archive "$target_dir"

  # If this script was run from travis,
  # write the filepath of the generated zip to a file.
  # (used by bin/travis-upload-atrifact script)
  if [ -n "$TRAVIS" ]; then
    local file_with_path="${ROOT}/.travis-release-path-${target}"
    local zip_path="${target_dir}.zip"
    echo -n "$zip_path" > "$file_with_path"
  fi

  if should_build_with_controller; then
    local prev_spacing="$spacing"
    spacing="$spacing  "
    msg "${prev_spacing}Compiling with controller support..."
    cd "${RELEASE_DIR}"
    local exe_name="${RELEASE_EXE_NAME_OUTPUT}${CONTROLLER_SUPPORT_SUFFIX}"
    exe_name="${exe_name/.exe${CONTROLLER_SUPPORT_SUFFIX}/${CONTROLLER_SUPPORT_SUFFIX}.exe}"
    local zip_name="${RELEASE_FILE_PREFIX}${target}${RELEASE_FILE_SUFFIX}-${RELEASE_VERSION}${CONTROLLER_SUPPORT_SUFFIX}.zip"
    local features
    if [ -n "$RELEASE_FEATURES" ]; then
      features="${RELEASE_FEATURES},controller"
    else
      features="controller"
    fi
    also_to_stderr="$RELEASE_PRINT_CARGO_STDERR" try_run \
      "cargo +${RELEASE_RUST_VERSION} build --release --features $features $*"
    try_run "cp ${RUST_TARGET_DIR}/${RELEASE_EXE_NAME} ${exe_name}"
    if [ "$target" = "windows" ]; then
      try_run "cp ${ROOT}/SDL2.dll ."
      try_run "zip -r $zip_name $exe_name SDL2.dll"
      try_run "rm -f ${exe_name} SDL2.dll"
    else
      try_run "zip -r $zip_name $exe_name"
      try_run "rm -f $exe_name"
    fi
    spacing="$prev_spacing"
  fi
}

function should_build_with_controller {
  [ -n "$RELEASE_WITH_CONTROLLER" ] && [ "$RELEASE_WITH_CONTROLLER" != "0" ]
}

# Set global settings variables.
[ -z "$RELEASE_TARGETS" ] && RELEASE_TARGETS="linux windows"
RELEASE_TARGETS=($RELEASE_TARGETS)
[ -z "$RELEASE_DIR" ]                && RELEASE_DIR="${ROOT}/releases"
[ -d "$RELEASE_DIR" ]                || mkdir -p "$RELEASE_DIR"
[ -z "$RELEASE_VERSION" ]            && RELEASE_VERSION="cargo"
[ -z "$RELEASE_FILE_PREFIX" ]        && RELEASE_FILE_PREFIX="ld44-postjam-"
[ -z "$RELEASE_FILE_SUFFIX" ]        && RELEASE_FILE_SUFFIX=""
[ -z "$RELEASE_EXE_NAME" ]           && RELEASE_EXE_NAME="ld44-stabman"
[ -z "$RELEASE_EXE_NAME_OUTPUT" ]    && RELEASE_EXE_NAME_OUTPUT="Stabman"
[ -z "$RELEASE_RESOURCES_DIR" ]      && RELEASE_RESOURCES_DIR="${ROOT}/resources"
[ -z "$RELEASE_RUST_VERSION" ]       && RELEASE_RUST_VERSION="1.34.2"
[ -z "$RELEASE_FEATURES" ]           && RELEASE_FEATURES=""
[ -z "$RELEASE_WITH_CONTROLLER" ]    && RELEASE_WITH_CONTROLLER="0"
[ -z "$RELEASE_PRINT_CARGO_STDERR" ] && RELEASE_PRINT_CARGO_STDERR=""

run "$@"
